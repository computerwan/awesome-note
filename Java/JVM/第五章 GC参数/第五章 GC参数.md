###1、堆回顾
* 堆分为两类：

eden s0(from) s1(to) tenured
新生代     幸存代      老年代


###2、串行收集器
* 最古老，最稳定
* 效率高
* 可能会产生较长的停顿
* -XX:+UseSerialGC
	* 新生代、老年代使用串行回收
	* 新生代复制算法（Serial）
	* 老年代标记-压缩（Serial Old）

###3、并行收集器
（ParNew）
* -XX:+UseParNewGC
* Serial收集器新生代的并行版本
* 复制算法
* 多线程，需要多核支持
* -XX:ParallelGCThreads 限制线程数量

（Parallel收集器）
* 类似ParNew
* 新生代复制算法
* 老年代 标记-压缩
* 更加关注吞吐量
* -XX +UseParallelGC
	* 使用Parallel收集器+老年代串行
* -XX +UseParallelOldGC
	* 使用Parallel收集器+并行老年代
* -XX:MaxGCPauseMills
	* 最大停顿时间，单位毫秒
	* GC尽力保证回收时间不超过设定值
* -XX：GCTimeRatio
	* 0-100的取值范围
	* 垃圾收集时间占总时间的比
	* 默认99，即最大允许1%的时间做GC
	* 以上两个参数是矛盾的，因为停顿时间和吞吐量不可能同时调优。

###4、CMS收集器
* Concurrent Mark Sweep 并发标记清除
* 标记-清除算法
* 与标记-压缩相比
* 并发阶段会降低吞吐量
* 老年代收集器（新生代使用ParNew）
* -XX:+UseConcMarkSweepGC
* CMS运行过程比较复杂，着重实现了标记的过程
	* 初始标记（速度快，根可以直接关联到的对象）
	* 并发标记（和用户线程一起，主要标记过程，标记全部对象）
	* 重新标记（由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正）
	* 并发清除（和用户线程一起，基于标记结果，直接清除对象）

特点：
* 尽可能降低停顿
* 会影响系统整体吞吐量和性能
* 清理不彻底
* 因为和用户线程一起运行，不能再空间快满的时再清理


为了减轻GC压力：
* 软件如何设计架构
* 代码如何写
* 堆空间如何分配

###5、Tomcat实例演示

测试网络吞吐量和延时
使用工具：Jmeter