# JVM虚拟机

### 1. Java GC机制
> 1. GC是针对的对象(可达性分析法)
2. 什么时候开始GC(当新生代满了会进行Minor GC，升到老年代的对象大于老年代剩余空间时会进行Major GC)
3. GC做什么(新生代采用复制算法，老年代采用标记-清除或标记-整理算法)

1. 可达性分析：通过将GC roots对象作为起始点，从这些点开始向下搜索，搜索走过的路称为引用链，当一个对象没有任何引用链相连时，该对象不可用。
2. 当新生代满了会进行Minor GC，升到老年代的对象大于老年代剩余空间时会进行Major GC；gc与非gc时间耗时超过了GCTimeRatio的限制引发OOM
3. 主要的垃圾收集算法包括：标记-清除；复制算法；标记-整理；分代收集算法。
  * 新生代采用复制算法（将内存分为两部分，当一部分用完之后，将存活的对象复制到另外一块上面，然后将这一部分一次性清除掉。缺点浪费空间）
  * 对老年代采用标记-清除（标记需要回收的对象，然后统一回收所有被标记的对象缺点有碎片，效率）或者标记-整理（标记后，将所有存活的对象移动到一端，然后将需要回收的对象清理，缺点效率）

### 2. 哪些值可以作为GC roots
  1. 虚拟机的栈中引用的对象；
  2. 方法中类静态属性引用的对象；
  3. 方法区中常量引用的对象；
  4. 本地方法栈中JNI引用的对象。

### 3. 新生代，老年代，持久代分别是什么？
  1. 新生代(Young Generation):所有新生对象首先放在年轻代，其作用是尽可能收集掉生命周期短的对象。分为三个区：一个Eden区，两个Survivor区。先放Eden区，如果Eden满了，还存活的被复制到Survivor区，满了如果还存活，复制到另外一个Survivor区。如果满了还存活，复制到年老区。（复制算法，Survivor两者没有主次，总有一个是空的）
  2. 保存什么周期较长的对象。即存放年轻代经过N次垃圾回收后仍然存活的对象。
  3. 持久代存放一些静态文件，如类信息，常量，静态变量等。

### 4. JVM如何加载一个类的过程，双亲委派模型中有哪些方法？
1. 加载-->连接（验证+准备+解析）-->初始化
  * 加载：jar，网络，反射（动态代理）
  * 验证：确保class文件字节流包含的信息符合虚拟机要求
  * 准备：分配空间+变量初始化(类变量)
  * 解析：虚拟机将常量池内的符号引用替换为直接引用的过程
  * 初始化：new对象，静态对象，常量，反射，父类，main方法时候执行初始化
2. 类加载器的顺序：启动类加载器>>扩展类加载器>>应用类加载器>>自定义类加载器
3. 双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。所有请求都会传到顶层启动类加载器中，只有当父加载器无法加载请求时，子加载器才会尝试自己加载。

### 5. JVM分哪些区，每个区的作用？
1. 栈 基本数据类型，String，对象和数组的指针-->线程私有
2. 堆 数组，对象实例（包括新生代和老生代，可以物理内存上不连续）-->线程共享
3. 方法区 类信息，常量，静态变量（永久带，不需要连续，可以不垃圾回收）
  - 对象的方法放在方法区，只有调用的时候才会构建方法的运行时环境：包括参数和局部变量
4. 本地方法栈（使用Native方法）
5. 程序计数器 通过改变计数器的值选取下一条需要执行的字节码指令-->线程私有

### 6.JVM内存模型（JMM）
1. 定义程序中各个变量的访问规则，包括：实例字段，静态字段和数组对象。(局部变量和方法参数不参与共享)
2. 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存(Main memory)中，每个线程都有一个私有的本地内存(local memory),本地内存中存储了主内存的副本。**线程对变量的所有操作，都必须在工作内存进行**
3. 主内存直接对应物理硬件的内存，工作内存有限存储在寄存器和高速缓存中。

### 7.栈溢出和堆溢出
[参考](http://www.importnew.com/14604.html)
* 栈溢出（stackOverlfowError）
  * 因为方法运行的时候栈的深度超过了虚拟机容许的最大深度导致的
* 堆溢出（OutOfMemoryError）
  * 可能内存泄漏，需要找到泄漏对象是怎么被GC ROOT引用起来的，然后通过引用链来具体分析泄漏得原因。
  * 如果出现内存泄漏问题，因为程序本身需要的内存大于虚拟机配置的内存，可以通过调大-Xmx来解决问题。
* 持久带溢出(OutOfMemoryError: PermGen space)
  * Class对象未被释放，Class对象占用信息过多，过多的Class对象
* 无法创建本地线程(OutOfMemoryError:unable to create native thread)
  * 总容量不变，堆内存，非堆内存设置过大，会导致能给线程的内存不足。

### 8.内存溢出和内存泄漏的区别
* 内存溢出：程序在申请内存时，没有足够的内存空间供其使用。
* 内存泄漏：指申请内存后，无法释放已经申请的内存空间，即new后不归还。

### 9.四种类型的引用
* 强引用：普遍存在，垃圾回收器永远不会回收
* 软引用(softReference):有用但非必须，只有系统快要发生内存溢出之前，才回收
* 弱引用(weakReference):只能活到下一次垃圾收集发生之前
* 虚引用(PhantomReference):无法使用，唯一作用：在对象被回收之前收到一个通知

### 10.JVM启动参数
-Xms 堆的最小值
-Xmx 堆得最大值
-Xss 设置栈
-XX PermSize 方法区大小
-XX MaxPermSize 最大方法区大小
-XX MaxDirectMemorySize 最大堆外内存

### 11.几种常用的内存调试工具：jmap、jstack、jconsole
*jmap* ： 获取dump文件（堆转储快照），查询finalize执行队列，Java堆和永久带信息
jstack ： 用于生成当前线程快照，每条线程当前执行的方法堆和栈的集合
jconsole ：内存，线程等可视化监控

### 12. 分派：静态分派与动态分派(8.3.2)
* Human man = new Man();
* 两个概念：静态类型（变量声明时类型，Human）和实际类型（变量实例化时采用类型，man）

静态分派：发生在编译期，根据静态类型确定，主要有：重载
动态分派：发生在运行期间，根据动态类型确定，主要有：重写(override)
