##目录：
二叉树（binary tree）
字符串（String）
排序

##二叉树（binary tree）

####1. 二叉树按层遍历
1. 针对二叉树的宽度优先遍历
2. 宽度优先遍历常使用队列结构
3. 面试时，需要连同行号都打印出来


####2. 二叉树的序列化和反序列化
1. 二叉树——>字符串（序列化）
	* 根据先序遍历序列化
	* 根据中序遍历序列化
	* 根据后序遍历序列化
	* 按层序列化
2. 字符串——>二叉树 （反序列化）
	用什么方式序列化，就选择什么方式反序列化

* 先序遍历对二叉树进行序列化
	1. 假设序列化结果为str，初始时str为空字符串.
	2. 先序遍历二叉树时如果遇到空节点，在str末尾加上"#!".
	3. 如果遇到不为空的节点，假设节点值为3，就在str的末尾加上"3!".
	注：用一个特殊字符表示一个二叉树节点值的结束的意义

* 按层遍历的方式对二叉树进行序列化
	1. 用队列来进行二叉树的按层遍历，即宽度优先遍历
	2. 除了访问节点的顺序是按层遍历之外，对结果字符串的处理，与之前介绍的处理方式一样。



##排序
####1、冒泡排序
比较区间0~N-1，相邻的数进行比较，最大的数放在后面。然后比较区间变为0~N-2，依次执行。

####2、选择排序
比较区间0~N-1，选出最小值放在位置0上，然后比较区间变为1~N-1，依次执行。

####3、插入排序
第一个数与第二个数比较，小的放前面，后面的依次与前面的数进行比较，最小的排前面，依次执行。

####4、归并排序
两个数组按顺便合并，依次执行。

####5、快速排序
随机选一个数，小于等于的数放在左边，大于的放在右边。递归的对两边再进行排序。

划分过程：
1、 划分值放在数组最后的位置
2、 设计一个小于等于区间，初始时候长度为0
3、 如果与最后一个数比较，小于最后一个数，则放在区间中。
4、最后将划分值放到区间后面。

####6、堆排序
1、首先建立为大小为N的大更堆，堆顶是其值最大的地方。
2、首先将堆顶的值与其最后一个位置的数交换。
3、将N-1的大小的堆进行调整，获得最大值
4、依次循环

####7、希尔排序（改进插入排序）
插入排序步长为1
1、假设步长为3，跳三位比较，第四位与第一位比较，小的放前面
2、第五位与第二位比较...第七位与第第四位比较，如果小，则再与第一位比较。
3、步长调整为2，循环，最后调整为1.

希尔排序的关键：步长的选择

不是基于比较的排序算法，思想来源于桶排序
####8、计数排序
先按照经验，划分区间（例如身高区间），将其划分到区间中，从低开始依次将员工倒出，就获得排序结果
####9、基数排序
1、根据个位上的数，将其划分到0~9，10个桶里面，获得序列
2、再根据十位上的数，将其划分到桶里面。
3、循环到最高位。最后依次倒出的序列就是整个序列。

####10、经典排序算法的空间复杂度
O(1)
插入排序、选择排序、冒泡排序、堆排序、希尔排序
O(logN)~O(N)
快速排序
O(N)
归并排序
O(M)
计数排序，基数排序（M是桶的数量）

####11、经典排序算法的稳定性
稳定性的概念：嘉定待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，称这种排序算法是稳定的，否则称为不稳定的。

稳定的排序算法：
冒泡排序，插入排序，归并排序，计数排序，基数排序，桶排序

不稳定的排序：
选择排序，快速排序，希尔排序，堆排序
（三个相同的数-->顺序会改变）

####12、补充
桶排序：准备桶可能会造成空间浪费
工程上排序：综合排序
	* 数组比较小时，插入排序
	* 数组大的时候，会选O(NlogN)的排序

####13、例题

13.1 小范围排序 
已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的举例不超过k，并且k相对于数组长度来说很小。请问选择什么方法对其排序比较好。
计数排序、基数排序：不基于比较的排序算法的限制，不适用所有情况
冒泡排序、选择排序：这两个排序算法与数组原始序列无关
插入排序：插入排序的过程与原始顺序有关，每个元素移动距离不超过K
快速排序，归并排序：与数组原始顺序无关
答案：改进后的堆排序O（N*logK）

13.2 判断数组中是否有重复值。必须保证额外空间复杂度为O(1)
	如果没有空间复杂度限制，用hash表实现
	时间复杂度O(N),空间复杂度为O(N)
	先排序，然后判断，空间复杂度为O(1)，要选堆排序，但需要改进版本的堆排序

13.3把两个有序数组合为一个数组。第一个数组空间正好可以容纳两个数组的元素。
数字A 2 4 6 _ _ _ (从后往前覆盖)
数字B 1 3 5 

13.4 荷兰国旗问题。只包含0，1，2的整数数组进行排序，要求使用交换、原地排序，而不是利用计数进行排序。
答：与快排的原理类似。
在前面设一个0区域，后面设一个2区域，然后指针中内容与之比较。当前位置与2区域重合的时候，整个过程停止。

13.5 在行列都排好序的矩阵中找数
	0 1 2 5 
	2 3 4 7
	4 4 4 8
	5 7 7 9
如果k为7，返回true；如果k为6，返回false
答：从二维数组的**右上角**开始找，如果要找的数比自己大，到下面找，如果比自己数小，到左边找。

13.6 需要排序的最短子数组长度[1,5,4,3,2,6,7]，返回4，因为只有[5,4,3,2]需要排序。
答：从左往右遍历，只关注遍历后的最大值，记录下面，关注被比起小的值，记录最右位置的数。再从右往左遍历，只关注遍历后的最小值，记录比其大的值，记录最左位置的数。两者范围就是需要遍历的组。

13.7 给定一个整型数组arr，返回如果排序之后，相邻两数的最大差值。
例如：某数组排序之后为 1 2 3 4 7 8 9
最大差值来自与4和7，所以返回3
答：思想来自桶排序，找最小值和最大值，等量的分为N个区间。只要记录两个桶之间最大值和最小值的差值。


